{"ast":null,"code":"export const CANVAS_WIDTH = 10;\nexport const CANVAS_HEIGHT = 20;\nexport const createCanvas = () => Array.from(Array(CANVAS_HEIGHT), () => new Array(CANVAS_WIDTH).fill([0, 'clear']));\nexport const checkCollision = (current, canvas, {\n  x: moveX,\n  y: moveY\n}) => {\n  for (let y = 0; y < current.tetromino.length; y++) {\n    for (let x = 0; x < current.tetromino[y].length; x++) {\n      // 1. check if it's tetromino cell or empty cell\n      if (current.tetromino[y][x] !== 0) {\n        if ( // 2. check if it's inside of the canvas(height = y)\n        !canvas[y + current.pos.y + moveY] || // 3. check if it's inside of the canvas(width = x)\n        !canvas[y + current.pos.y + moveY][x + current.pos.x + moveX] || // 4. check if it's not empty where tetromino move to\n        canvas[y + current.pos.y + moveY][x + current.pos.x + moveX][1] !== 'clear') {\n          return true;\n        }\n      }\n    }\n  }\n};","map":{"version":3,"sources":["C:/jah-workspace/tetris-js/react-js/src/settingGame.js"],"names":["CANVAS_WIDTH","CANVAS_HEIGHT","createCanvas","Array","from","fill","checkCollision","current","canvas","x","moveX","y","moveY","tetromino","length","pos"],"mappings":"AAAA,OAAO,MAAMA,YAAY,GAAG,EAArB;AACP,OAAO,MAAMC,aAAa,GAAG,EAAtB;AAEP,OAAO,MAAMC,YAAY,GAAG,MACxBC,KAAK,CAACC,IAAN,CAAWD,KAAK,CAACF,aAAD,CAAhB,EAAiC,MAC7B,IAAIE,KAAJ,CAAUH,YAAV,EAAwBK,IAAxB,CAA6B,CAAC,CAAD,EAAI,OAAJ,CAA7B,CADJ,CADG;AAKP,OAAO,MAAMC,cAAc,GAAG,CAACC,OAAD,EAAUC,MAAV,EAAkB;AAACC,EAAAA,CAAC,EAACC,KAAH;AAAUC,EAAAA,CAAC,EAACC;AAAZ,CAAlB,KAAyC;AACnE,OAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,OAAO,CAACM,SAAR,CAAkBC,MAAtC,EAA8CH,CAAC,EAA/C,EAAmD;AAC/C,SAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,OAAO,CAACM,SAAR,CAAkBF,CAAlB,EAAqBG,MAAzC,EAAiDL,CAAC,EAAlD,EAAsD;AAClD;AACA,UAAIF,OAAO,CAACM,SAAR,CAAkBF,CAAlB,EAAqBF,CAArB,MAA4B,CAAhC,EAAmC;AAC/B,aACI;AACA,SAACD,MAAM,CAACG,CAAC,GAAGJ,OAAO,CAACQ,GAAR,CAAYJ,CAAhB,GAAoBC,KAArB,CAAP,IACA;AACA,SAACJ,MAAM,CAACG,CAAC,GAAGJ,OAAO,CAACQ,GAAR,CAAYJ,CAAhB,GAAoBC,KAArB,CAAN,CAAkCH,CAAC,GAAGF,OAAO,CAACQ,GAAR,CAAYN,CAAhB,GAAoBC,KAAtD,CAFD,IAGA;AACAF,QAAAA,MAAM,CAACG,CAAC,GAAGJ,OAAO,CAACQ,GAAR,CAAYJ,CAAhB,GAAoBC,KAArB,CAAN,CAAkCH,CAAC,GAAGF,OAAO,CAACQ,GAAR,CAAYN,CAAhB,GAAoBC,KAAtD,EAA6D,CAA7D,MAAoE,OANxE,EAOE;AACE,iBAAO,IAAP;AACH;AACJ;AACJ;AACJ;AACJ,CAlBM","sourcesContent":["export const CANVAS_WIDTH = 10;\r\nexport const CANVAS_HEIGHT = 20;\r\n\r\nexport const createCanvas = () => \r\n    Array.from(Array(CANVAS_HEIGHT), () =>\r\n        new Array(CANVAS_WIDTH).fill([0, 'clear'])\r\n    )\r\n\r\nexport const checkCollision = (current, canvas, {x:moveX, y:moveY}) => {\r\n    for (let y = 0; y < current.tetromino.length; y++) {\r\n        for (let x = 0; x < current.tetromino[y].length; x++) {\r\n            // 1. check if it's tetromino cell or empty cell\r\n            if (current.tetromino[y][x] !== 0) {\r\n                if(\r\n                    // 2. check if it's inside of the canvas(height = y)\r\n                    !canvas[y + current.pos.y + moveY] || \r\n                    // 3. check if it's inside of the canvas(width = x)\r\n                    !canvas[y + current.pos.y + moveY][x + current.pos.x + moveX] ||\r\n                    // 4. check if it's not empty where tetromino move to\r\n                    canvas[y + current.pos.y + moveY][x + current.pos.x + moveX][1] !== 'clear'\r\n                ) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}