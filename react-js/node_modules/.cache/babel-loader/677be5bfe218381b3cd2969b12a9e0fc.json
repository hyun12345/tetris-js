{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useState, useEffect } from 'react';\nimport { createCanvas } from '../settingGame';\nexport const useCanvas = (current, resetCurrent) => {\n  _s();\n\n  const [canvas, setCanvas] = useState(createCanvas());\n  const [rowsCleared, setRowsCleared] = useState(0);\n  useEffect(() => {\n    setRowsCleared(0);\n\n    const sweepRows = newCanvas => {\n      // array.reduce() testing\n      let arr = [[[0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear']], [[0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear']], [[0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear']], [[0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear']], [[0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear']]];\n      arr.reduce((acc, row) => {\n        console.log({\n          acc: acc\n        });\n        console.log({\n          row: row\n        }); // acc.unshift(['O', 'merged']);\n        // console.log({accc:acc});\n        // return acc + curr;\n      }); // console.log({sum:sum});\n      // console.log({newCanvas:newCanvas});\n      // acc : accumulator\n\n      newCanvas.reduce((acc, row) => {// console.log({acc:acc});\n        // console.log({row:row});\n        // if (row.findIndex(cell => cell[0] === 0) === -1) {\n        //     setRowsCleared(prev => prev + 1);\n        //     acc.unshift(new Array(newCanvas[0].length).fill([0, 'clear']));\n        //     // console.log({if:acc})\n        //     // return acc;\n        // }\n        // acc.push(row);\n        // console.log({else:acc})\n        // return acc;\n      }, []);\n    }; // compare with prevCanvas\n\n\n    const updateCanvas = prevCanvas => {\n      // 1 : flush the canvas\n      const newCanvas = prevCanvas.map(row => row.map(cell => cell[1] === 'clear' ? [0, 'clear'] : cell)); // 2 : draw tetromino\n\n      current.tetromino.forEach((row, y) => {\n        row.forEach((value, x) => {\n          if (value !== 0) {\n            newCanvas[y + current.pos.y][x + current.pos.x] = [value, `${current.collided ? 'merged' : 'clear'}`];\n          }\n        });\n      }); // check if collided or not\n\n      if (current.collided) {\n        resetCurrent();\n        sweepRows(newCanvas); // return sweepRows(newCanvas);\n      }\n\n      return newCanvas;\n    };\n\n    setCanvas(prev => updateCanvas(prev));\n  }, [current, resetCurrent]);\n  return [canvas, setCanvas];\n};\n\n_s(useCanvas, \"01qeW7toOEGm+SAJf12G+DlmaI8=\");","map":{"version":3,"sources":["C:/jah-workspace/tetris-js/react-js/src/hooks/useCanvas.js"],"names":["useState","useEffect","createCanvas","useCanvas","current","resetCurrent","canvas","setCanvas","rowsCleared","setRowsCleared","sweepRows","newCanvas","arr","reduce","acc","row","console","log","updateCanvas","prevCanvas","map","cell","tetromino","forEach","y","value","x","pos","collided","prev"],"mappings":"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","sourcesContent":["import { useState, useEffect } from 'react';\r\nimport { createCanvas } from '../settingGame';\r\n\r\nexport const useCanvas = (current, resetCurrent) => {\r\n    const[canvas, setCanvas] = useState(createCanvas());\r\n    const [rowsCleared, setRowsCleared] = useState(0);\r\n\r\n    useEffect(() => {\r\n        setRowsCleared(0);\r\n\r\n        const sweepRows = newCanvas => {\r\n            // array.reduce() testing\r\n            let arr = [\r\n                [[0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear']],\r\n                [[0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear']],\r\n                [[0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear']],\r\n                [[0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear']],\r\n                [[0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear'], [0, 'clear']]\r\n        ];\r\n            arr.reduce((acc, row) => {\r\n                console.log({acc:acc});\r\n                console.log({row:row});\r\n                // acc.unshift(['O', 'merged']);\r\n                // console.log({accc:acc});\r\n                // return acc + curr;\r\n            });\r\n            // console.log({sum:sum});\r\n\r\n            // console.log({newCanvas:newCanvas});\r\n            // acc : accumulator\r\n            newCanvas.reduce((acc, row) => {\r\n                // console.log({acc:acc});\r\n                // console.log({row:row});\r\n                // if (row.findIndex(cell => cell[0] === 0) === -1) {\r\n                //     setRowsCleared(prev => prev + 1);\r\n                //     acc.unshift(new Array(newCanvas[0].length).fill([0, 'clear']));\r\n                //     // console.log({if:acc})\r\n                //     // return acc;\r\n                // }\r\n                // acc.push(row);\r\n                // console.log({else:acc})\r\n                // return acc;\r\n            }, []);\r\n        }\r\n\r\n        \r\n\r\n        // compare with prevCanvas\r\n        const updateCanvas = prevCanvas => {\r\n            // 1 : flush the canvas\r\n            const newCanvas = prevCanvas.map(row => \r\n                row.map(cell => (cell[1] === 'clear' ? [0, 'clear'] : cell)),\r\n            );\r\n\r\n            // 2 : draw tetromino\r\n            current.tetromino.forEach((row, y) => {\r\n                row.forEach((value, x) => {\r\n                    if (value !== 0) {\r\n                        newCanvas[y + current.pos.y][x + current.pos.x] = [\r\n                            value,\r\n                            `${current.collided ? 'merged' : 'clear'}`,\r\n                        ]\r\n                    }\r\n                });\r\n            });\r\n            // check if collided or not\r\n            if (current.collided) {\r\n                resetCurrent();\r\n                sweepRows(newCanvas);\r\n                // return sweepRows(newCanvas);\r\n            }\r\n\r\n            return newCanvas;\r\n        };\r\n\r\n        setCanvas(prev => updateCanvas(prev));\r\n    }, [current, resetCurrent]);\r\n\r\n    return [canvas, setCanvas];\r\n}"]},"metadata":{},"sourceType":"module"}