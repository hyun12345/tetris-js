{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useEffect } from 'react';\nimport { createBoard } from '../settingGame'; // using react-redux\n\nimport { useSelector, useDispatch } from 'react-redux';\nimport * as actions from '../_actions/index';\nexport var useBoard = function useBoard(current, resetCurrent) {\n  _s();\n\n  var dispatch = useDispatch();\n  var tetris = useSelector(function (store) {\n    return store.tetris;\n  });\n  useEffect(function () {\n    // setRowsCleared(0);\n    dispatch(actions.setBoard(createBoard()));\n    dispatch(actions.setRowsCleared(0));\n\n    var sweepRows = function sweepRows(newBoard) {\n      return (// acc : accumulator\n        newBoard.reduce(function (acc, row) {\n          if (row.findIndex(function (cell) {\n            return cell[0] === 0;\n          }) === -1) {\n            dispatch(actions.setRowsCleared(function (prev) {\n              return prev + 1;\n            })); // setRowsCleared(prev => prev + 1);\n\n            acc.unshift(new Array(newBoard[0].length).fill([0, 'clear']));\n            return acc;\n          }\n\n          acc.push(row);\n          return acc;\n        }, [])\n      );\n    }; // compare with prevBoard\n\n\n    var updateBoard = function updateBoard(prevBoard) {\n      // 1 : flush the board\n      var newBoard = prevBoard.map(function (row) {\n        return row.map(function (cell) {\n          return cell[1] === 'clear' ? [0, 'clear'] : cell;\n        });\n      }); // 2 : draw tetromino\n\n      current.tetromino.forEach(function (row, y) {\n        row.forEach(function (value, x) {\n          if (value !== 0) {\n            newBoard[y + current.pos.y][x + current.pos.x] = [value, \"\".concat(current.collided ? 'merged' : 'clear')];\n          }\n        });\n      }); // check if collided or not\n\n      if (current.collided) {\n        // if last block not touched the top\n        if (current.pos.y > 0) {\n          resetCurrent();\n          return sweepRows(newBoard);\n        }\n      }\n\n      return newBoard;\n    };\n\n    dispatch(actions.setBoard(function (prev) {\n      return updateBoard(prev);\n    }));\n  }, [current, resetCurrent, dispatch]);\n  return [tetris.rowsCleared];\n};\n\n_s(useBoard, \"eJEeSUksA4oBaBo/RgGSAmKR5gg=\", false, function () {\n  return [useDispatch, useSelector];\n});","map":{"version":3,"sources":["C:/jah-workspace/tetris-js/react-js/src/_hooks/useBoard.js"],"names":["useEffect","createBoard","useSelector","useDispatch","actions","useBoard","current","resetCurrent","dispatch","tetris","store","setBoard","setRowsCleared","sweepRows","newBoard","reduce","acc","row","findIndex","cell","prev","unshift","Array","length","fill","push","updateBoard","prevBoard","map","tetromino","forEach","y","value","x","pos","collided","rowsCleared"],"mappings":"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","sourcesContent":["import { useEffect } from 'react';\r\nimport { createBoard } from '../settingGame';\r\n\r\n// using react-redux\r\nimport { useSelector, useDispatch } from 'react-redux';\r\nimport * as actions from '../_actions/index';\r\n\r\nexport const useBoard = (current, resetCurrent) => {\r\n    const dispatch = useDispatch();\r\n    const tetris = useSelector((store) => store.tetris);\r\n\r\n    useEffect(() => {\r\n        // setRowsCleared(0);\r\n        dispatch(actions.setBoard(createBoard()));\r\n        dispatch(actions.setRowsCleared(0));\r\n        const sweepRows = newBoard =>\r\n            // acc : accumulator\r\n            newBoard.reduce((acc, row) => {\r\n                if (row.findIndex(cell => cell[0] === 0) === -1) {\r\n                    dispatch(actions.setRowsCleared(prev => prev + 1));\r\n                    // setRowsCleared(prev => prev + 1);\r\n                    acc.unshift(new Array(newBoard[0].length).fill([0, 'clear']));\r\n                    return acc;\r\n                }\r\n                acc.push(row);\r\n                return acc;\r\n            }, []);\r\n\r\n        // compare with prevBoard\r\n        const updateBoard = prevBoard => {\r\n            // 1 : flush the board\r\n            const newBoard = prevBoard.map(row =>\r\n                row.map(cell => (cell[1] === 'clear' ? [0, 'clear'] : cell))\r\n            );\r\n\r\n            // 2 : draw tetromino\r\n            current.tetromino.forEach((row, y) => {\r\n                row.forEach((value, x) => {\r\n                    if (value !== 0) {\r\n                        newBoard[y + current.pos.y][x + current.pos.x] = [value, `${current.collided ? 'merged' : 'clear'}`,];\r\n                    }\r\n                });\r\n            });\r\n            \r\n            // check if collided or not\r\n            if (current.collided) {\r\n                // if last block not touched the top\r\n                if (current.pos.y > 0) {\r\n                    resetCurrent();\r\n                    return sweepRows(newBoard);\r\n                }\r\n            }\r\n            return newBoard;\r\n          };\r\n\r\n          dispatch(actions.setBoard(prev => updateBoard(prev)));\r\n      }, [current, resetCurrent, dispatch, ]);\r\n      return [tetris.rowsCleared];\r\n};\r\n"]},"metadata":{},"sourceType":"module"}