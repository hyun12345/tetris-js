{"ast":null,"code":"import _slicedToArray from \"C:/jah-workspace/tetris-js/react-js/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\nvar _s = $RefreshSig$();\n\nimport { useState, useEffect } from 'react';\nimport { createCanvas } from '../settingGame';\nexport var useCanvas = function useCanvas(current, resetPlayer) {\n  _s();\n\n  var _useState = useState(createCanvas()),\n      _useState2 = _slicedToArray(_useState, 2),\n      canvas = _useState2[0],\n      setCanvas = _useState2[1];\n\n  var _useState3 = useState(0),\n      _useState4 = _slicedToArray(_useState3, 2),\n      rowsCleared = _useState4[0],\n      setRowsCleared = _useState4[1];\n\n  useEffect(function () {\n    setRowsCleared(0);\n\n    var sweepRows = function sweepRows(newCanvas) {\n      return (// acc : accumulator\n        newCanvas.reduce(function (acc, row) {\n          if (row.findIndex(function (cell) {\n            return cell[0] === 0;\n          }) === -1) {\n            setRowsCleared(function (prev) {\n              return prev + 1;\n            });\n            acc.unshift(new Array(newCanvas[0].length).fill([0, 'clear']));\n            return acc;\n          }\n\n          acc.push(row);\n          return acc;\n        }, [])\n      );\n    }; // compare with prevCanvas\n\n\n    var updateCanvas = function updateCanvas(prevCanvas) {\n      // 1 : flush the canvas\n      var newCanvas = prevCanvas.map(function (row) {\n        return row.map(function (cell) {\n          return cell[1] === 'clear' ? [0, 'clear'] : cell;\n        });\n      }); // 2 : draw tetromino\n\n      current.tetromino.forEach(function (row, y) {\n        row.forEach(function (value, x) {\n          if (value !== 0) {\n            newCanvas[y + current.pos.y][x + current.pos.x] = [value, \"\".concat(current.collided ? 'merged' : 'clear')];\n          }\n        });\n      }); // check if collided or not\n\n      if (current.collided) {\n        resetPlayer();\n        return sweepRows(newCanvas);\n      }\n\n      return newCanvas;\n    };\n\n    setCanvas(function (prev) {\n      return updateCanvas(prev);\n    });\n  }, [current, resetPlayer]);\n  return [canvas, setCanvas, rowsCleared];\n};\n\n_s(useCanvas, \"01qeW7toOEGm+SAJf12G+DlmaI8=\");","map":{"version":3,"sources":["C:/jah-workspace/tetris-js/react-js/src/_hooks/useCanvas.js"],"names":["useState","useEffect","createCanvas","useCanvas","current","resetPlayer","canvas","setCanvas","rowsCleared","setRowsCleared","sweepRows","newCanvas","reduce","acc","row","findIndex","cell","prev","unshift","Array","length","fill","push","updateCanvas","prevCanvas","map","tetromino","forEach","y","value","x","pos","collided"],"mappings":";;;;AAAA,SAASA,QAAT,EAAmBC,SAAnB,QAAoC,OAApC;AACA,SAASC,YAAT,QAA6B,gBAA7B;AAEA,OAAO,IAAMC,SAAS,GAAG,SAAZA,SAAY,CAACC,OAAD,EAAUC,WAAV,EAA0B;AAAA;;AAC/C,kBAA4BL,QAAQ,CAACE,YAAY,EAAb,CAApC;AAAA;AAAA,MAAOI,MAAP;AAAA,MAAeC,SAAf;;AACA,mBAAsCP,QAAQ,CAAC,CAAD,CAA9C;AAAA;AAAA,MAAOQ,WAAP;AAAA,MAAoBC,cAApB;;AAEAR,EAAAA,SAAS,CAAC,YAAM;AACZQ,IAAAA,cAAc,CAAC,CAAD,CAAd;;AACA,QAAMC,SAAS,GAAG,SAAZA,SAAY,CAAAC,SAAS;AAAA,aACvB;AACAA,QAAAA,SAAS,CAACC,MAAV,CAAiB,UAACC,GAAD,EAAMC,GAAN,EAAc;AAC3B,cAAIA,GAAG,CAACC,SAAJ,CAAc,UAAAC,IAAI;AAAA,mBAAIA,IAAI,CAAC,CAAD,CAAJ,KAAY,CAAhB;AAAA,WAAlB,MAAyC,CAAC,CAA9C,EAAiD;AAC7CP,YAAAA,cAAc,CAAC,UAAAQ,IAAI;AAAA,qBAAIA,IAAI,GAAG,CAAX;AAAA,aAAL,CAAd;AACAJ,YAAAA,GAAG,CAACK,OAAJ,CAAY,IAAIC,KAAJ,CAAUR,SAAS,CAAC,CAAD,CAAT,CAAaS,MAAvB,EAA+BC,IAA/B,CAAoC,CAAC,CAAD,EAAI,OAAJ,CAApC,CAAZ;AACA,mBAAOR,GAAP;AACH;;AACDA,UAAAA,GAAG,CAACS,IAAJ,CAASR,GAAT;AACA,iBAAOD,GAAP;AACH,SARD,EAQG,EARH;AAFuB;AAAA,KAA3B,CAFY,CAcZ;;;AACA,QAAMU,YAAY,GAAG,SAAfA,YAAe,CAAAC,UAAU,EAAI;AAC/B;AACA,UAAMb,SAAS,GAAGa,UAAU,CAACC,GAAX,CAAe,UAAAX,GAAG;AAAA,eAChCA,GAAG,CAACW,GAAJ,CAAQ,UAAAT,IAAI;AAAA,iBAAKA,IAAI,CAAC,CAAD,CAAJ,KAAY,OAAZ,GAAsB,CAAC,CAAD,EAAI,OAAJ,CAAtB,GAAqCA,IAA1C;AAAA,SAAZ,CADgC;AAAA,OAAlB,CAAlB,CAF+B,CAM/B;;AACAZ,MAAAA,OAAO,CAACsB,SAAR,CAAkBC,OAAlB,CAA0B,UAACb,GAAD,EAAMc,CAAN,EAAY;AAClCd,QAAAA,GAAG,CAACa,OAAJ,CAAY,UAACE,KAAD,EAAQC,CAAR,EAAc;AACtB,cAAID,KAAK,KAAK,CAAd,EAAiB;AACblB,YAAAA,SAAS,CAACiB,CAAC,GAAGxB,OAAO,CAAC2B,GAAR,CAAYH,CAAjB,CAAT,CAA6BE,CAAC,GAAG1B,OAAO,CAAC2B,GAAR,CAAYD,CAA7C,IAAkD,CAACD,KAAD,YAAWzB,OAAO,CAAC4B,QAAR,GAAmB,QAAnB,GAA8B,OAAzC,EAAlD;AACH;AACJ,SAJD;AAKH,OAND,EAP+B,CAe/B;;AACA,UAAI5B,OAAO,CAAC4B,QAAZ,EAAsB;AAClB3B,QAAAA,WAAW;AACX,eAAOK,SAAS,CAACC,SAAD,CAAhB;AACH;;AACD,aAAOA,SAAP;AACD,KArBH;;AAuBEJ,IAAAA,SAAS,CAAC,UAAAU,IAAI;AAAA,aAAIM,YAAY,CAACN,IAAD,CAAhB;AAAA,KAAL,CAAT;AACH,GAvCM,EAuCJ,CAACb,OAAD,EAAUC,WAAV,CAvCI,CAAT;AAyCE,SAAO,CAACC,MAAD,EAASC,SAAT,EAAoBC,WAApB,CAAP;AACL,CA9CM;;GAAML,S","sourcesContent":["import { useState, useEffect } from 'react';\r\nimport { createCanvas } from '../settingGame';\r\n\r\nexport const useCanvas = (current, resetPlayer) => {\r\n    const [canvas, setCanvas] = useState(createCanvas());\r\n    const [rowsCleared, setRowsCleared] = useState(0);\r\n\r\n    useEffect(() => {\r\n        setRowsCleared(0);\r\n        const sweepRows = newCanvas =>\r\n            // acc : accumulator\r\n            newCanvas.reduce((acc, row) => {\r\n                if (row.findIndex(cell => cell[0] === 0) === -1) {\r\n                    setRowsCleared(prev => prev + 1);\r\n                    acc.unshift(new Array(newCanvas[0].length).fill([0, 'clear']));\r\n                    return acc;\r\n                }\r\n                acc.push(row);\r\n                return acc;\r\n            }, []);\r\n\r\n        // compare with prevCanvas\r\n        const updateCanvas = prevCanvas => {\r\n            // 1 : flush the canvas\r\n            const newCanvas = prevCanvas.map(row =>\r\n                row.map(cell => (cell[1] === 'clear' ? [0, 'clear'] : cell))\r\n            );\r\n\r\n            // 2 : draw tetromino\r\n            current.tetromino.forEach((row, y) => {\r\n                row.forEach((value, x) => {\r\n                    if (value !== 0) {\r\n                        newCanvas[y + current.pos.y][x + current.pos.x] = [value, `${current.collided ? 'merged' : 'clear'}`,];\r\n                    }\r\n                });\r\n            });\r\n            \r\n            // check if collided or not\r\n            if (current.collided) {\r\n                resetPlayer();\r\n                return sweepRows(newCanvas);\r\n            }\r\n            return newCanvas;\r\n          };\r\n\r\n          setCanvas(prev => updateCanvas(prev));\r\n      }, [current, resetPlayer,]);\r\n\r\n      return [canvas, setCanvas, rowsCleared];\r\n};\r\n"]},"metadata":{},"sourceType":"module"}