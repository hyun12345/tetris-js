{"ast":null,"code":"import _slicedToArray from \"C:/jah-workspace/tetris-js/react-js/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\nvar _s = $RefreshSig$();\n\nimport { useState, useEffect } from 'react';\nimport { createBoard, checkIsIE, closeIEAlert } from '../settingGame';\nimport { useSelector, useDispatch } from 'react-redux';\nimport * as actions from '../_actions/index';\nexport var useBoard = function useBoard(current, resetCurrent) {\n  _s();\n\n  var _useState = useState(createBoard()),\n      _useState2 = _slicedToArray(_useState, 2),\n      board = _useState2[0],\n      setBoard = _useState2[1];\n\n  var _useState3 = useState(0),\n      _useState4 = _slicedToArray(_useState3, 2),\n      rowsCleared = _useState4[0],\n      setRowsCleared = _useState4[1];\n\n  var dispatch = useDispatch();\n  var tetris = useSelector(function (store) {\n    return store.tetris;\n  });\n  useEffect(function () {\n    setRowsCleared(0);\n\n    var sweepRows = function sweepRows(newBoard) {\n      return (// acc : accumulator\n        newBoard.reduce(function (acc, row) {\n          if (row.findIndex(function (cell) {\n            return cell[0] === 0;\n          }) === -1) {\n            setRowsCleared(function (prev) {\n              return prev + 1;\n            });\n            acc.unshift(new Array(newBoard[0].length).fill([0, 'clear']));\n            return acc;\n          }\n\n          acc.push(row);\n          return acc;\n        }, [])\n      );\n    }; // compare with prevBoard\n\n\n    var updateBoard = function updateBoard(prevBoard) {\n      // 1 : flush the board\n      var newBoard = prevBoard.map(function (row) {\n        return row.map(function (cell) {\n          return cell[1] === 'clear' ? [0, 'clear'] : cell;\n        });\n      }); // 2 : draw tetromino\n\n      current.tetromino.forEach(function (row, y) {\n        row.forEach(function (value, x) {\n          if (value !== 0) {\n            newBoard[y + current.pos.y][x + current.pos.x] = [value, \"\".concat(current.collided ? 'merged' : 'clear')];\n          }\n        });\n      }); // check if collided or not\n\n      if (current.collided) {\n        // if last block not touched the top\n        if (current.pos.y > 0) {\n          resetCurrent();\n          return sweepRows(newBoard);\n        }\n      }\n\n      return newBoard;\n    };\n\n    setBoard(function (prev) {\n      return updateBoard(prev);\n    });\n    dispatch(actions.setIsIE(checkIsIE()));\n    dispatch(actions.setIEAlert(closeIEAlert()));\n  }, [current, resetCurrent, dispatch]);\n  return [board, setBoard, rowsCleared];\n};\n\n_s(useBoard, \"xCmnR1OV47zSkFbiEE3MWHpDu38=\", false, function () {\n  return [useDispatch, useSelector];\n});","map":{"version":3,"sources":["C:/jah-workspace/tetris-js/react-js/src/_hooks/useBoard.js"],"names":["useState","useEffect","createBoard","checkIsIE","closeIEAlert","useSelector","useDispatch","actions","useBoard","current","resetCurrent","board","setBoard","rowsCleared","setRowsCleared","dispatch","tetris","store","sweepRows","newBoard","reduce","acc","row","findIndex","cell","prev","unshift","Array","length","fill","push","updateBoard","prevBoard","map","tetromino","forEach","y","value","x","pos","collided","setIsIE","setIEAlert"],"mappings":"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","sourcesContent":["import { useState, useEffect } from 'react';\r\nimport { createBoard, checkIsIE, closeIEAlert} from '../settingGame';\r\n\r\nimport { useSelector, useDispatch } from 'react-redux';\r\nimport * as actions from '../_actions/index';\r\n\r\nexport const useBoard = (current, resetCurrent) => {\r\n    const [board, setBoard] = useState(createBoard());\r\n    const [rowsCleared, setRowsCleared] = useState(0);\r\n    const dispatch = useDispatch();\r\n    const tetris = useSelector((store) => store.tetris);\r\n\r\n    useEffect(() => {\r\n        setRowsCleared(0);\r\n        const sweepRows = newBoard =>\r\n            // acc : accumulator\r\n            newBoard.reduce((acc, row) => {\r\n                if (row.findIndex(cell => cell[0] === 0) === -1) {\r\n                    setRowsCleared(prev => prev + 1);\r\n                    acc.unshift(new Array(newBoard[0].length).fill([0, 'clear']));\r\n                    return acc;\r\n                }\r\n                acc.push(row);\r\n                return acc;\r\n            }, []);\r\n\r\n        // compare with prevBoard\r\n        const updateBoard = prevBoard => {\r\n            // 1 : flush the board\r\n            const newBoard = prevBoard.map(row =>\r\n                row.map(cell => (cell[1] === 'clear' ? [0, 'clear'] : cell))\r\n            );\r\n\r\n            // 2 : draw tetromino\r\n            current.tetromino.forEach((row, y) => {\r\n                row.forEach((value, x) => {\r\n                    if (value !== 0) {\r\n                        newBoard[y + current.pos.y][x + current.pos.x] = [value, `${current.collided ? 'merged' : 'clear'}`,];\r\n                    }\r\n                });\r\n            });\r\n            \r\n            // check if collided or not\r\n            if (current.collided) {\r\n                // if last block not touched the top\r\n                if (current.pos.y > 0) {\r\n                    resetCurrent();\r\n                    return sweepRows(newBoard);\r\n                }\r\n            }\r\n            return newBoard;\r\n          };\r\n\r\n          setBoard(prev => updateBoard(prev));\r\n          dispatch(actions.setIsIE(checkIsIE()));\r\n          dispatch(actions.setIEAlert(closeIEAlert()));\r\n      }, [current, resetCurrent, dispatch]);\r\n\r\n      return [board, setBoard, rowsCleared];\r\n};\r\n"]},"metadata":{},"sourceType":"module"}