{"ast":null,"code":"export var CANVAS_WIDTH = 10;\nexport var CANVAS_HEIGHT = 20;\nexport var createCanvas = function createCanvas() {\n  return Array.from(Array(CANVAS_HEIGHT), function () {\n    return Array(CANVAS_WIDTH).fill([0, 'clear']);\n  });\n};\nexport var checkCollision = function checkCollision(current, canvas, _ref) {\n  var moveX = _ref.x,\n      moveY = _ref.y;\n\n  for (var y = 0; y < current.tetromino.length; y++) {\n    for (var x = 0; x < current.tetromino[y].length; x++) {\n      // 1. check if it's tetromino cell or empty cell\n      if (current.tetromino[y][x] !== 0) {\n        if ( // 2. check if it's inside of the canvas(height = y)\n        !canvas[y + current.pos.y + moveY] || // 3. check if it's inside of the canvas(width = x)\n        !canvas[y + current.pos.y + moveY][x + current.pos.x + moveX] || // 4. check if it's not empty where tetromino move to\n        canvas[y + current.pos.y + moveY][x + current.pos.x + moveX][1] !== 'clear') {\n          return true;\n        }\n      }\n    }\n  } // if collided return false\n\n\n  return false;\n};","map":{"version":3,"sources":["C:/jah-workspace/tetris-js/react-js/src/settingGame.js"],"names":["CANVAS_WIDTH","CANVAS_HEIGHT","createCanvas","Array","from","fill","checkCollision","current","canvas","moveX","x","moveY","y","tetromino","length","pos"],"mappings":"AAAA,OAAO,IAAMA,YAAY,GAAG,EAArB;AACP,OAAO,IAAMC,aAAa,GAAG,EAAtB;AAEP,OAAO,IAAMC,YAAY,GAAG,SAAfA,YAAe;AAAA,SACxBC,KAAK,CAACC,IAAN,CAAWD,KAAK,CAACF,aAAD,CAAhB,EAAiC;AAAA,WAAME,KAAK,CAACH,YAAD,CAAL,CAAoBK,IAApB,CAAyB,CAAC,CAAD,EAAI,OAAJ,CAAzB,CAAN;AAAA,GAAjC,CADwB;AAAA,CAArB;AAGP,OAAO,IAAMC,cAAc,GAAG,SAAjBA,cAAiB,CAACC,OAAD,EAAUC,MAAV,QAAyC;AAAA,MAApBC,KAAoB,QAAtBC,CAAsB;AAAA,MAAXC,KAAW,QAAbC,CAAa;;AACnE,OAAK,IAAIA,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,OAAO,CAACM,SAAR,CAAkBC,MAAtC,EAA8CF,CAAC,EAA/C,EAAmD;AAC/C,SAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,OAAO,CAACM,SAAR,CAAkBD,CAAlB,EAAqBE,MAAzC,EAAiDJ,CAAC,EAAlD,EAAsD;AAClD;AACA,UAAIH,OAAO,CAACM,SAAR,CAAkBD,CAAlB,EAAqBF,CAArB,MAA4B,CAAhC,EAAmC;AAC/B,aACI;AACA,SAACF,MAAM,CAACI,CAAC,GAAGL,OAAO,CAACQ,GAAR,CAAYH,CAAhB,GAAoBD,KAArB,CAAP,IACA;AACA,SAACH,MAAM,CAACI,CAAC,GAAGL,OAAO,CAACQ,GAAR,CAAYH,CAAhB,GAAoBD,KAArB,CAAN,CAAkCD,CAAC,GAAGH,OAAO,CAACQ,GAAR,CAAYL,CAAhB,GAAoBD,KAAtD,CAFD,IAGA;AACAD,QAAAA,MAAM,CAACI,CAAC,GAAGL,OAAO,CAACQ,GAAR,CAAYH,CAAhB,GAAoBD,KAArB,CAAN,CAAkCD,CAAC,GAAGH,OAAO,CAACQ,GAAR,CAAYL,CAAhB,GAAoBD,KAAtD,EAA6D,CAA7D,MAAoE,OANxE,EAOE;AACE,iBAAO,IAAP;AACH;AACJ;AACJ;AACJ,GAjBkE,CAkBnE;;;AACA,SAAO,KAAP;AACH,CApBM","sourcesContent":["export const CANVAS_WIDTH = 10;\r\nexport const CANVAS_HEIGHT = 20;\r\n\r\nexport const createCanvas = () =>\r\n    Array.from(Array(CANVAS_HEIGHT), () => Array(CANVAS_WIDTH).fill([0, 'clear']));\r\n\r\nexport const checkCollision = (current, canvas, {x:moveX, y:moveY}) => {\r\n    for (let y = 0; y < current.tetromino.length; y++) {\r\n        for (let x = 0; x < current.tetromino[y].length; x++) {\r\n            // 1. check if it's tetromino cell or empty cell\r\n            if (current.tetromino[y][x] !== 0) {\r\n                if (\r\n                    // 2. check if it's inside of the canvas(height = y)\r\n                    !canvas[y + current.pos.y + moveY] ||\r\n                    // 3. check if it's inside of the canvas(width = x)\r\n                    !canvas[y + current.pos.y + moveY][x + current.pos.x + moveX] ||\r\n                    // 4. check if it's not empty where tetromino move to\r\n                    canvas[y + current.pos.y + moveY][x + current.pos.x + moveX][1] !== 'clear'\r\n                ) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // if collided return false\r\n    return false;\r\n};\r\n"]},"metadata":{},"sourceType":"module"}