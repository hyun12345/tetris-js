{"ast":null,"code":"import _slicedToArray from \"C:/jah-workspace/tetris-js/react-js/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\nvar _s = $RefreshSig$();\n\nimport { useState, useEffect } from 'react';\nimport { createBoard, checkIsIE, setIEAlert } from '../settingGame';\nimport { useSelector, useDispatch } from 'react-redux';\nimport * as actions from '../../../_actions/index';\nexport var useBoard = function useBoard(current, resetCurrent) {\n  _s();\n\n  var _useState = useState(createBoard()),\n      _useState2 = _slicedToArray(_useState, 2),\n      board = _useState2[0],\n      setBoard = _useState2[1];\n\n  var _useState3 = useState(0),\n      _useState4 = _slicedToArray(_useState3, 2),\n      rowsCleared = _useState4[0],\n      setRowsCleared = _useState4[1];\n\n  var _useState5 = useState(checkIsIE()),\n      _useState6 = _slicedToArray(_useState5, 2),\n      isIE = _useState6[0],\n      setIsIE = _useState6[1]; // const [closeAlert, setCloseAlert] = useState(checkCloseAlert());\n\n\n  useEffect(function () {\n    setRowsCleared(0);\n\n    var sweepRows = function sweepRows(newBoard) {\n      return (// acc : accumulator\n        newBoard.reduce(function (acc, row) {\n          if (row.findIndex(function (cell) {\n            return cell[0] === 0;\n          }) === -1) {\n            setRowsCleared(function (prev) {\n              return prev + 1;\n            });\n            acc.unshift(new Array(newBoard[0].length).fill([0, 'clear']));\n            return acc;\n          }\n\n          acc.push(row);\n          return acc;\n        }, [])\n      );\n    }; // compare with prevBoard\n\n\n    var updateBoard = function updateBoard(prevBoard) {\n      // 1 : flush the board\n      var newBoard = prevBoard.map(function (row) {\n        return row.map(function (cell) {\n          return cell[1] === 'clear' ? [0, 'clear'] : cell;\n        });\n      }); // 2 : draw tetromino\n\n      current.tetromino.forEach(function (row, y) {\n        row.forEach(function (value, x) {\n          if (value !== 0) {\n            newBoard[y + current.pos.y][x + current.pos.x] = [value, \"\".concat(current.collided ? 'merged' : 'clear')];\n          }\n        });\n      }); // check if collided or not\n\n      if (current.collided) {\n        // if last block not touched the top\n        if (current.pos.y > 0) {\n          resetCurrent();\n          return sweepRows(newBoard);\n        }\n      }\n\n      return newBoard;\n    };\n\n    setBoard(function (prev) {\n      return updateBoard(prev);\n    });\n    setIsIE(checkIsIE()); //   setCloseAlert(checkCloseAlert());\n  }, [current, resetCurrent]);\n  return [board, setBoard, rowsCleared, isIE];\n};\n\n_s(useBoard, \"AkgihgdP5jXi0BT7CmPjy951YiI=\");","map":{"version":3,"sources":["C:/jah-workspace/tetris-js/react-js/src/_hooks/useBoard.js"],"names":["useState","useEffect","createBoard","checkIsIE","setIEAlert","useSelector","useDispatch","actions","useBoard","current","resetCurrent","board","setBoard","rowsCleared","setRowsCleared","isIE","setIsIE","sweepRows","newBoard","reduce","acc","row","findIndex","cell","prev","unshift","Array","length","fill","push","updateBoard","prevBoard","map","tetromino","forEach","y","value","x","pos","collided"],"mappings":"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","sourcesContent":["import { useState, useEffect } from 'react';\r\nimport { createBoard, checkIsIE, setIEAlert} from '../settingGame';\r\n\r\nimport { useSelector, useDispatch } from 'react-redux';\r\nimport * as actions from '../../../_actions/index';\r\n\r\nexport const useBoard = (current, resetCurrent) => {\r\n    const [board, setBoard] = useState(createBoard());\r\n    const [rowsCleared, setRowsCleared] = useState(0);\r\n    const [isIE, setIsIE] = useState(checkIsIE());\r\n    // const [closeAlert, setCloseAlert] = useState(checkCloseAlert());\r\n\r\n    useEffect(() => {\r\n        setRowsCleared(0);\r\n        const sweepRows = newBoard =>\r\n            // acc : accumulator\r\n            newBoard.reduce((acc, row) => {\r\n                if (row.findIndex(cell => cell[0] === 0) === -1) {\r\n                    setRowsCleared(prev => prev + 1);\r\n                    acc.unshift(new Array(newBoard[0].length).fill([0, 'clear']));\r\n                    return acc;\r\n                }\r\n                acc.push(row);\r\n                return acc;\r\n            }, []);\r\n\r\n        // compare with prevBoard\r\n        const updateBoard = prevBoard => {\r\n            // 1 : flush the board\r\n            const newBoard = prevBoard.map(row =>\r\n                row.map(cell => (cell[1] === 'clear' ? [0, 'clear'] : cell))\r\n            );\r\n\r\n            // 2 : draw tetromino\r\n            current.tetromino.forEach((row, y) => {\r\n                row.forEach((value, x) => {\r\n                    if (value !== 0) {\r\n                        newBoard[y + current.pos.y][x + current.pos.x] = [value, `${current.collided ? 'merged' : 'clear'}`,];\r\n                    }\r\n                });\r\n            });\r\n            \r\n            // check if collided or not\r\n            if (current.collided) {\r\n                // if last block not touched the top\r\n                if (current.pos.y > 0) {\r\n                    resetCurrent();\r\n                    return sweepRows(newBoard);\r\n                }\r\n            }\r\n            return newBoard;\r\n          };\r\n\r\n          setBoard(prev => updateBoard(prev));\r\n          setIsIE(checkIsIE());\r\n        //   setCloseAlert(checkCloseAlert());\r\n      }, [current, resetCurrent,]);\r\n\r\n      return [board, setBoard, rowsCleared, isIE];\r\n};\r\n"]},"metadata":{},"sourceType":"module"}